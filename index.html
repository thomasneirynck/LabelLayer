<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body, html {
            width: 100%;
            height: 100%;
            margin: 0 auto;
        }

        #wrapper {
            position: relative;
            margin: 0 auto;
            width: 100%;
            height: 100%;
            /*width: 256px;*/
            /*height: 256px;*/
            border: 1px solid red;
            user-select: none;
        }

        .label {
            overflow: hidden;
            box-shadow: 10px 10px 5px #888888;
            /*width: 1px;*/
            /*height: 1px;*/
            color: white;
            border: 1px solid red;
            background-color: dimgrey;
            border-radius: 10px;
            padding: 10px;

        }
    </style>
</head>
<body>


<div id="wrapper"></div>

<script>


    //todo: replace with ints for faster comparison
    const STATUS = {
//        NOT_INITIALIZED: 'not_initialized',
        NOT_INITIALIZED: 0,
//        ON_SCREEN: 'on_screen',
        ON_SCREEN: 1,
//        OFF_SCREEN: 'off_screen'
        OFF_SCREEN: 2
    };


    class LinkedListNode {

        constructor() {
            this._nextNode = null;
        }

        setNextNode(linkedListNode) {
            this._nextNode = linkedListNode;
        }

        getNextNode() {
            return this._nextNode;
        }

    }


    class CenteredAnchorGenerator {
        constructor(x, y) {
            this._anchor = new Anchor(x, y);
            this._done = false;
        }

        reset() {
            this._done = false;
        }

        hasNext() {
            return !this._done;
        }

        next() {
            this._done = true;
            return this._anchor;
        }
    }


    class Anchor {
        constructor(x, y) {
            //default is centered position
            this._shiftX = -0.5;
            this._shiftY = -0.5;
            this._offsetX = 0;
            this._offsetY = 0;
            this._x = x;
            this._y = y;
        }

        setXY(x, y) {
            if (this._x === x || this._y === y) {
                return false;
            }
            this._x = x;
            this._y = y;
            return true;
        }

        getLeft(width) {
            return this._x + width * this._shiftX + this._offsetX;
        }

        getTop(height) {
            return this._y + height * this._shiftY + this._offsetY;
        }
    }


    class Label extends LinkedListNode {

        constructor(labelLayer, htmlContents, anchorGenerator) {

            super();

            //todo :this doesn't work the way it is supposed to
            this._anchorGenerator = anchorGenerator;
            this._anchor = this._anchorGenerator.next();


            this._contents = htmlContents;
            this._labelLayer = labelLayer;
            this._width = -1;
            this._height = -1;
            this._priority = 0;
            this._i = -1;
            this._shouldRemove = false;

            this._domDiv = null;


            this._tmpLabelComp = null;
        }

        setTmpLabelComp(tmpLabel) {
            this._tmpLabelComp = tmpLabel;
        }

        getTmpLabelComp() {
            return this._tmpLabelComp;
        }

        getAnchor() {
            if (!this._anchor) {

            }
            return this._anchor;
        }

        removeDomDivReference() {
            this._domDiv = null;
        }

        getDOMDiv() {
            return this._domDiv;
        }

        setPriority(priority) {
            return this._priority = priority;
        }

        //the lower the priority nr, the earlier it should be placed
        getPriority() {
            return this._priority;
        }

        setStatus(status) {
            this._status = status;
        }

        getStatus() {
            return this._status;
        }


        intersects(label) {

            if (
                    this.getViewX() + this._width < label.getViewX() ||
                    label.getViewX() + label.getWidth() < this.getViewX() ||
                    this.getViewY() + this._height < label.getViewY() ||
                    label.getViewY() + label.getHeight() < this.getViewY()
            ) {
                return false;
            }

            return true;


        }

        getViewX() {
            return this._anchor.getLeft(this._width);
        }

        getViewY() {
            return this._anchor.getTop(this._height);
        }

        getWidth() {
            return this._width;
        }

        getHeight() {
            return this._height;
        }

        setDomDiv(div) {
            div.innerHTML = this._contents;
            this._domDiv = div;
        }

        dirtyPosition(newX, newY) {
            this._isDirtyPosition = this._anchor.setXY(newX, newY);
        }

        isDirty() {
            return this._isDirtyPosition;
        }

        unDirtyPosition() {
            this._isDirtyPosition = false;
        }

        measure(measureDiv) {
            measureDiv.innerHTML = this._contents;
            this._width = measureDiv.offsetWidth;
            this._height = measureDiv.offsetHeight;
            measureDiv.innerHTML = '';
            this._cells = this._labelLayer.createCellsForLabel(this._width, this._height, this);
        }

        getCell() {
            this._i++;
            if (this._i >= this._cells.length) {
                throw new Error('this should never happen');
            }
            return this._cells[this._i];
        }

        unhookAllCells() {
            //unhook all the cells (if any
            this._i = -1;
            if (!this._cells) {
                return;
            }

            for (let i = 0; i < this._cells.length; i++) {
                const cellToRemove = this._cells[i];
                const previousCell = cellToRemove.getPreviousNodeDLL();
                const nextCell = cellToRemove.getNextNodeDLL();
                cellToRemove.setPreviousNodeDLL(null);
                cellToRemove.setNextNodeDLL(null);
                if (previousCell) {
                    previousCell.setNextNodeDLL(nextCell);
                }
                if (nextCell) {
                    nextCell.setPreviousNodeDLL(previousCell);
                }
            }
        }

        setShouldRemove(remove) {
            this._shouldRemove = remove;
        }

        getShouldRemove() {
            return this._shouldRemove;
        }

    }


    //kind of hacky, but we want to both use a cell as an element in the gridcell
    // - link each cell to all the labels inside
    // - link each label to all of its cells
    class DoublyLinkedListNode {
        constructor() {
            this._nextNodeDLL = null;
            this._previousNodeDLL = null;
        }

        setNextNodeDLL(cell) {
            this._nextNodeDLL = cell;
        }

        getNextNodeDLL() {
            return this._nextNodeDLL;
        }

        setPreviousNodeDLL(cell) {
            this._previousNodeDLL = cell;
        }

        getPreviousNodeDLL() {
            return this._previousNodeDLL;
        }
    }


    class Cell extends DoublyLinkedListNode {
        constructor(label) {
            super();
            this._label = label;
        }

        getLabel() {
            return this._label;
        }
    }

    class Grid {


        constructor(width, height) {
            this._w = width;
            this._h = height;

            const targetSize = 64;
//            const targetSize = 32;
            this._cols = Math.round(this._w / targetSize);
            this._rows = Math.round(this._h / targetSize);
            this._cellWidth = Math.round(this._w / this._cols);
            this._cellHeight = Math.round(this._h / this._rows);


            this._cellArray = new Array(this._cols * this._rows);
            for (let i = 0; i < this._cellArray.length; i++) {
                this._cellArray[i] = new Cell(null);
            }
        }

        createCellsForLabel(w, h, label) {

            //create at least one extra cell in every dimension
            const cols = Math.ceil(w / this._cellWidth + 1);
            const rows = Math.ceil(h / this._cellHeight + 1);

            const cells = new Array(cols * rows);
            for (let i = 0; i < cells.length; i++) {
                cells[i] = new Cell(label);
            }

            return cells;
        }

        clearGrid() {
            for (let i = 0; i < this._cellArray.length; i++) {
                this._cellArray[i].setNextNodeDLL(null);
                this._cellArray[i].setPreviousNodeDLL(null);
            }
        }


        _toCol(x) {

        }

        _toRow(y) {

        }

        hasConflicts(label) {

            const x = label.getViewX();
            const y = label.getViewY();

            const w = label.getWidth();
            const h = label.getHeight();

            const colStart = Math.max(0, Math.floor(x / this._cellWidth));
            const colEnd = Math.min(Math.ceil((x + w) / this._cellWidth), this._cols);
            const rowStart = Math.max(0, Math.floor(y / this._cellHeight));
            const rowEnd = Math.min(Math.ceil((y + h) / this._cellHeight), this._rows);


            for (let c = colStart; c < colEnd; c++) {
                for (let r = rowStart; r < rowEnd; r++) {
                    const index = this.toIndex(c, r);
                    const gridCell = this._cellArray[index];
                    let cell = gridCell.getNextNodeDLL();
                    while (cell) {
                        const compLabel = cell.getLabel();
                        if (compLabel.getTmpLabelComp() !== label) {
                            if (compLabel.intersects(label)) {
                                return true;
                            } else {
                                compLabel.setTmpLabelComp(label);
                            }
                        } else {
                            compLabel.setTmpLabelComp(label);
                        }
                        cell = cell.getNextNodeDLL();
                    }
                }
            }
            return false;
        }

        place(cell, x, y, w, h) {


        }

        toIndex(x, y) {
            return x * this._rows + y;
        }

        markLabel(label) {


            const x = label.getViewX();
            const y = label.getViewY();

            const w = label.getWidth();
            const h = label.getHeight();

            const colStart = Math.max(0, Math.floor(x / this._cellWidth));
            const colEnd = Math.min(Math.ceil((x + w) / this._cellWidth), this._cols);
            const rowStart = Math.max(0, Math.floor(y / this._cellHeight));
            const rowEnd = Math.min(Math.ceil((y + h) / this._cellHeight), this._rows);

            for (let c = colStart; c < colEnd; c++) {
                for (let r = rowStart; r < rowEnd; r++) {
                    const index = this.toIndex(c, r);
                    const gridCell = this._cellArray[index];
                    const labelCell = label.getCell();

                    const nextCell = gridCell.getNextNodeDLL()
                    labelCell.setPreviousNodeDLL(gridCell);
                    gridCell.setNextNodeDLL(labelCell);

                    labelCell.setNextNodeDLL(nextCell);
                    if (nextCell) {
                        nextCell.setPreviousNodeDLL(labelCell);
                    }
                }
            }


        }

        draw(context2d) {
            for (let c = 0; c < this._cols; c++) {
                for (let r = 0; r < this._rows; r++) {
                    const index = this.toIndex(c, r);

                    const cell = this._cellArray[index];
                    context2d.fillStyle = cell.getNextNodeDLL() === null ? 'rgba(0,255,0, 0.1)' : 'rgba(255,0,0,0.1)';
                    context2d.strokeStyle = cell.getNextNodeDLL() === null ? 'rgba(0,255,0, 0.5)' : 'rgba(255,0,0,0.5)';
                    context2d.fillRect(c * this._cellWidth, r * this._cellHeight, this._cellWidth, this._cellHeight);
                    context2d.strokeRect(c * this._cellWidth, r * this._cellHeight, this._cellWidth, this._cellHeight);
                }
            }
        }


    }


    class LabelLayer extends LinkedListNode {

        constructor(container) {

            super();
            this._containerDiv = container;

            //div to place labels in
            this._labelDiv = document.createElement('div');
            this._labelDiv.style.position = 'absolute';
            this._labelDiv.style.border = '1px solid green';
            this._labelDiv.style.left = 0;
            this._labelDiv.style.top = 0;
            this._labelDiv.style.overflow = 'hidden';
            this._containerDiv.appendChild(this._labelDiv);

            //div to measure labels in
            this._measureDiv = document.createElement('div');
            this._measureDiv.style.position = 'absolute';
            this._measureDiv.style.visibility = 'hidden';
            this._measureDiv.style.left = 0;
            this._measureDiv.style.top = 0;
            this._containerDiv.appendChild(this._measureDiv);


            //dom management buffers
            this._labelsToRemoveFromDOM = [];
            this._labelsToAddToDOM = [];
            this._labelsToChangePositionForInDOM = [];


            //grids
            this._width = 0;
            this._height = 0;
            this._gridFront = null;
            this._gridBack = null;


            //draw state
            this._rafHandle = -1;

            //sizer
            this._updateSize = () => {

                const newWidth = this._containerDiv.clientWidth;
                const newHeight = this._containerDiv.clientHeight;

                if (this._width === newWidth && this._height === newHeight) {
                    return;
                }

                this._width = newWidth;
                this._height = newHeight;
                this._labelDiv.style.width = this._width + 'px';
                this._labelDiv.style.height = this._height + 'px';

                //copy the grids in here...
                if (this._gridFront) {
                    this._gridFront.clearGrid();
                    this._gridBack.clearGrid();
                }
                this._gridFront = new Grid(this._width, this._height);
                this._gridBack = new Grid(this._width, this._height);

                this._invalidate();

            };
            window.addEventListener('resize', this._updateSize);
            this._updateSize();


        }

        destroy() {
            this.setNextNode(null);
            window.removeEventListener('resize', this._updateSize);
            this._containerDiv.innerHTML = null;
        }

        resize() {
            this._updateSize();
        }

        makeAndAddLabel(htmlContents, priority, anchorGenerator) {
            const labelHandle = new Label(this, htmlContents, anchorGenerator);
            labelHandle.setPriority(priority);
            labelHandle.setStatus(STATUS.NOT_INITIALIZED);
            this._addLabel(labelHandle);
            return labelHandle;
        }

        addLabel(labelHandle) {
            labelHandle.setShouldRemove(false);
            this._addLabel(labelHandle);
        }

        moveLabel(labelHandle, x, y) {
            labelHandle.dirtyPosition(x, y);
            this._invalidate();
        }

        removeLabel(labelHandle) {
            labelHandle.setShouldRemove(true);
            this._invalidate();
        }


        //todo: his is buggy, because it doesnt add it in the right position
        changeLabelPriority(labelToMove, newPriority) {

            if (labelToMove.getPriority() === newPriority) {
                return;
            }


            let previousNode = this;
            let node = previousNode.getNextNode();


            let nodeBeforeTarget = null;
            let nodeToInsertOn = null;

            while (node) {

                if (node === labelToMove) {
                    nodeBeforeTarget = previousNode;
                }
                const nextNode = node.getNextNode();
                const foundInsertionNode = !nodeToInsertOn && (nextNode === null || node.getPriority() <= newPriority);
                if (foundInsertionNode) {
                    nodeToInsertOn = previousNode;
                }

                if (nodeBeforeTarget && nodeToInsertOn) {
                    if (labelToMove !== nodeToInsertOn) {
                        //remove the node
                        const nextAfterTarget = labelToMove.getNextNode();
                        labelToMove.setNextNode(null);
                        nodeBeforeTarget.setNextNode(nextAfterTarget);

                        //and insert into new position
                        const next = nodeToInsertOn.getNextNode();
                        labelToMove.setNextNode(next);
                        nodeToInsertOn.setNextNode(labelToMove);

                    }
                    break;
                }

                previousNode = node;
                node = previousNode.getNextNode();

            }

            labelToMove.setPriority(newPriority);
            this._invalidate();
        }

        _drawGrid(context) {
            this._gridFront.draw(context);
        }

        _invalidate() {
            if (this._rafHandle > -1) {
                return;
            }
            this._rafHandle = requestAnimationFrame(() => {
                this._rafHandle = -1;
                const bef = Date.now();
                this._updateStateOfAllLabels();
                console.log('time to draw', Date.now() - bef);
            });
        }

        _canAddToScreenAndMark(label, shouldCheck) {
            //these two function calls should be combined
            if (shouldCheck) {
                if (this._gridFront.hasConflicts(label)) {
                    return false;
                } else {
                    this._gridFront.markLabel(label);
                    return true;
                }
            } else {
                if (label.getStatus() === STATUS.ON_SCREEN) {
                    this._gridFront.markLabel(label);
                    return true;
                } else {
                    return false;
                }
            }

        }

        _updateStateOfAllLabels() {


//            console.log('update state---');
//            console.log(this._dumpLabelList('_status'));
            //decide what to do with each label (greedy)con

            //swap the grids. this is backwards. should just copy over elements...
            const tmp = this._gridBack;
            this._gridBack = this._gridFront;
            this._gridFront = tmp;
            this._gridFront.clearGrid();

            let previousNode = this;
            let label = previousNode.getNextNode();


            //todo keep track of first unintialized label or dirty label. this will trigger if we need to reposition
            let shouldCheckForConflicts = false;
            while (label) {

                const labelStatus = label.getStatus();
                const shouldRemove = label.getShouldRemove();

                shouldCheckForConflicts = shouldCheckForConflicts || labelStatus === STATUS.NOT_INITIALIZED;


                //mark the comp-label to null
                label.setTmpLabelComp(null);
                label.unhookAllCells();

                if (shouldRemove) {
                    const nextLabel = label.getNextNode();
                    label.setNextNode(null);
                    previousNode.setNextNode(nextLabel);
                    if (labelStatus === STATUS.ON_SCREEN) {
                        label.setStatus(STATUS.OFF_SCREEN);
                        this._labelsToRemoveFromDOM.push(label);
                    }
                    label = nextLabel;
                } else {
                    if (labelStatus === STATUS.NOT_INITIALIZED) {
                        label.measure(this._measureDiv);
                        if (this._canAddToScreenAndMark(label, shouldCheckForConflicts)) {
                            label.setStatus(STATUS.ON_SCREEN);
                            this._labelsToAddToDOM.push(label);
                        } else {
                            label.setStatus(STATUS.OFF_SCREEN);
                        }
                    } else if (labelStatus === STATUS.OFF_SCREEN) {
                        //check if can add
                        if (this._canAddToScreenAndMark(label, shouldCheckForConflicts)) {
                            label.setStatus(STATUS.ON_SCREEN);
                            this._labelsToAddToDOM.push(label);
                        }
                    } else if (labelStatus === STATUS.ON_SCREEN) {
                        if (this._canAddToScreenAndMark(label, shouldCheckForConflicts)) {
                            if (label.isDirty()) {
                                this._labelsToChangePositionForInDOM.push(label);
                                label.unDirtyPosition();
                            }
                        } else {
                            label.setStatus(STATUS.OFF_SCREEN);
                            this._labelsToRemoveFromDOM.push(label);
                        }
                    }

                    previousNode = label;
                    label = label.getNextNode();
                }
            }

            let labelToRemove = this._labelsToRemoveFromDOM.pop();
            while (labelToRemove) {
                this._labelDiv.removeChild(labelToRemove.getDOMDiv());
                labelToRemove.removeDomDivReference();
                labelToRemove = this._labelsToRemoveFromDOM.pop();
            }

            let labelToAdd = this._labelsToAddToDOM.pop();
            while (labelToAdd) {
                const div = document.createElement('div');
                div.style.position = 'absolute';
                labelToAdd.setDomDiv(div);
                div.style.left = labelToAdd.getViewX() + 'px';
                div.style.top = labelToAdd.getViewY() + 'px';
                div.style.width = labelToAdd.getWidth() + 1 + 'px';//ugh, how to measure borders?
                div.style.height = labelToAdd.getHeight() + 1 + 'px';//ugh, how to measure borders?
                this._labelDiv.appendChild(div);
                labelToAdd = this._labelsToAddToDOM.pop();
            }

            let labelToChangePositionFor = this._labelsToChangePositionForInDOM.pop();
            while (labelToChangePositionFor) {
                const div = labelToChangePositionFor.getDOMDiv();
                div.style.left = labelToChangePositionFor.getViewX() + 'px';
                div.style.top = labelToChangePositionFor.getViewY() + 'px';
                labelToChangePositionFor = this._labelsToChangePositionForInDOM.pop();
            }

//            console.log(this._dumpLabelList('_status'));

        }

        /**
         * sorted insert
         * @param headLL
         * @param nodeToInsert
         * @return {*} new head of LL
         * @private
         */
        _addTolinkedList(headLL, nodeToInsert) {

            if (headLL === null) {
                return nodeToInsert;
            }

            //is this a new head?
            if (headLL.getPriority() <= nodeToInsert.getPriority()) {
                nodeToInsert.setNextNode(headLL);
                return nodeToInsert;
            }

            //not new head, so anywhere else
            let currentNode = headLL;
            while (currentNode) {
                let nextNode = currentNode.getNextNode();
                const shouldInsert = nextNode === null || nextNode.getPriority() <= nodeToInsert.getPriority();
                if (shouldInsert) {
                    currentNode.setNextNode(nodeToInsert);
                    nodeToInsert.setNextNode(nextNode);
                    break;
                }
                currentNode = nextNode;
            }
            return headLL;
        }

        _dumpLabelList(property) {
            const labels = [];
            let label = this.getNextNode();
            while (label) {
                let thing;
                if (property) {
                    thing = label[property];
                } else {
                    thing = label;
                }
                labels.push(thing);
                label = label.getNextNode();
            }
            return labels;

        }

        _addLabel(labelHandle) {
            labelHandle.setStatus(STATUS.NOT_INITIALIZED);
            this._addToAllLabelList(labelHandle);
            this._invalidate();
            return labelHandle;
        }


        _addToAllLabelList(labelToAdd) {
            const newHead = this._addTolinkedList(this.getNextNode(), labelToAdd);
            this.setNextNode(newHead);
        }

        createCellsForLabel(width, height, label) {
            return this._gridFront.createCellsForLabel(width, height, label);
        }


    }


    ///////////////////////////////////////////////////////////////////////////


    const wrapper = document.getElementById('wrapper');
    const canvas = document.createElement('canvas');
    canvas.width = wrapper.clientWidth;
    canvas.height = wrapper.clientHeight;
    canvas.style.position = 'absolute';
    canvas.style.top = 0;
    canvas.style.left = 0;
    wrapper.appendChild(canvas);

    const context = canvas.getContext('2d');


    window.drawGrid = function () {

        context.clearRect(0, 0, canvas.width, canvas.height);
        labelLayer._drawGrid(context);

    };


    const div = document.getElementById('wrapper');
    const labelLayer = new LabelLayer(div);

    const labels = getLabels();


    const handles = labels.map((label)=> {
        const anchorGenerator = new CenteredAnchorGenerator(label.x, label.y);
        const handle = labelLayer.makeAndAddLabel(label.contents, label.priority, anchorGenerator);
        return handle;
    });


    window.labelLayer = labelLayer;
    window.handles = handles;


    function getLabels() {
        return [
            {
                contents: '<div style="border: 1px solid red; font-size: 32px; background-color: orange">foo</div>',
                x: 200,
                y: 90,
                priority: 4
            },
            {
                contents: '<div style="border: 1px solid red; font-size: 32px; background-color: orange">bar</div>',
                x: 200,
                y: 150,
                priority: 3
            },
//            {
//                contents: '<div style="border: 1px solid red; font-size: 32px; background-color: orange">HEYO!<br/>HELLO!</div>',
//                x: 280,
//                y: 250,
//                priority: 2
//            },
//            {
//                contents: '<div style="border: 1px solid red; font-size: 32px; background-color: orange">I got nothing</div>',
//                x: 140,
//                y: 70,
//                priority: 1
//            },


        ]
    }

    window._ly = labelLayer;


    let priority = 0
    let down = false;
    const handlez = [];
    window.moreHandles = handlez;
    wrapper.addEventListener('mousedown', function () {
        down = true;
    });

    wrapper.addEventListener('mouseup', function () {
        down = false;
    });


    wrapper.addEventListener('mousemove', function (event) {
        if (down) {

            let count = 0;
            while (count < 1) {


                const x = event.clientX + (Math.random() * 100) - 50;
                const y = event.clientY + (Math.random() * 100) - 50;

                const anchorGenerator = new CenteredAnchorGenerator(x, y);

                const label = `<div class="label";">Priority ${priority}<br/>foobar</div>`;
                const handle = labelLayer.makeAndAddLabel(label, -priority, anchorGenerator);
                priority++;
                handlez.push(handle);

                count++;
            }


        }
    });

    requestAnimationFrame(function draw() {
        drawGrid();
        requestAnimationFrame(draw);
    });
    window.addEventListener('resize', function () {
        canvas.width = wrapper.clientWidth;
        canvas.height = wrapper.clientHeight;
    });


</script>


</body>
</html>